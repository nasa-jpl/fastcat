#ifndef FASTCAT_DEVICE_CONFIG_PARSING_LIBYAMLCPP_HPP_
#define FASTCAT_DEVICE_CONFIG_PARSING_LIBYAMLCPP_HPP_

[[[cog
import yaml
import re

def snake2camel(str):
  return ''.join(x.capitalize() or '_' for x in str.split('_'))

cmd_data     = yaml.load(open(command_yaml, 'r'), Loader=yaml.Loader)
device_data  = yaml.load(open(device_yaml, 'r'), Loader=yaml.Loader)
enum_data    = yaml.load(open(enum_yaml, 'r'), Loader=yaml.Loader)
manager_data = yaml.load(open(manager_yaml, 'r'), Loader=yaml.Loader)

cog.outl('// This file is autogenerated from: %s' % cog_yaml_file)
cog.outl('// using the python cog tool.  Do not modify this file manually.')

native_types = ["double", 
                "bool", 
                "uint8_t",
                "uint16_t",
                "uint32_t",
                "int8_t",
                "int16_t",
                "int32_t"]
]]]
[[[end]]]


#include "fastcat/enum_conversions.h"

#include <yaml-cpp/yaml.h>
  
// Generate YAML template conversions using libyamlcpp extension class
namespace YAML {

/////////////////////////////
// Enumerations
/////////////////////////////

template<>
struct convert<::fastcat::DeviceType> {
  static Node encode(const ::fastcat::DeviceType& /*cfg*/) {
    Node node;
    node.push_back("BAD_DEVICE_TYPE"); // TODO
    return node;
  }

  static bool decode(const Node& node, ::fastcat::DeviceType& cfg) {
    const std::string& s = node.Scalar();
    cfg = ::fastcat::DeviceTypeFromString(s);
    return cfg != ::fastcat::BAD_DEVICE_TYPE;
  }
};

template<>
struct convert<::fastcat::DeviceCmdType> {
  static Node encode(const ::fastcat::DeviceCmdType& /*cfg*/) {
    Node node;
    node.push_back("BAD_DEVICE_CMD_TYPE"); // TODO
    return node;
  }

  static bool decode(const Node& node, ::fastcat::DeviceCmdType& cfg) {
    const std::string& s = node.Scalar();
    cfg = ::fastcat::DeviceCmdTypeFromString(s);
    return cfg != ::fastcat::BAD_DEVICE_CMD_TYPE;
  }
};

[[[cog
for this_enum in enum_data['enumerations']:

  camel = snake2camel(this_enum['name'])

  cog.outl('template<>')
  cog.outl('struct convert<::fastcat::%s> {' % camel)
  cog.outl('  static Node encode(const ::fastcat::%s& /*cfg*/) {' % camel)
  cog.outl('    Node node;')

  # TODO
  cog.outl('    node.push_back("BAD_%s"); // TODO' % this_enum['name'].upper())

  cog.outl('    return node;')
  cog.outl('  }')
  cog.outl('')
  cog.outl('  static bool decode(const Node& node, ::fastcat::%s& cfg) {' % camel)

  cog.outl('    const std::string& s = node.Scalar();')
  cog.outl('    cfg = ::fastcat::%sFromString(s);' % camel)

  cog.outl('    return cfg != ::fastcat::BAD_%s;' % this_enum['name'].upper())
  cog.outl('  }')
  cog.outl('};')

]]]
[[[end]]]


/////////////////////////////
// Device Config
/////////////////////////////

[[[cog
for device in device_data['devices']:

  if 'config' not in device:
    cog.outl('// Config not yet defined for %s' % device['name'])
    continue

  camel = snake2camel(device['name'])


  cog.outl('template<>')
  cog.outl('struct convert<::fastcat::%sConfig> {' % camel)
  cog.outl('  static Node encode(const ::fastcat::%sConfig& cfg) {' % camel)
  cog.outl('    Node node;')

  for field in device['config']: 
    cog.outl('    node["%s"] = cfg.%s;' % (field['name'], field['name']))

  cog.outl('    return node;')
  cog.outl('  }')
  cog.outl('')
  cog.outl('  static bool decode(const Node& node, ::fastcat::%sConfig& cfg) {' % camel)

  for field in device['config']: 
    if field['type'] in native_types or field['type'].startswith('std::'): 
      ns_type = field['type']
    else:
      ns_type = "::fastcat::" + field['type']
    cog.outl('    cfg.%s = node["%s"].as<%s>();' % (field['name'], field['name'], ns_type))

  cog.outl('    return true;')
  cog.outl('  }')
  cog.outl('};')

]]]
[[[end]]]

/////////////////////////////
// Device Config Variant
/////////////////////////////

[[[cog
cog.outl('template<>')
cog.outl('struct convert<::fastcat::DeviceConfig> {')
cog.outl('  static Node encode(const ::fastcat::DeviceConfig& /*cfg*/) {')
cog.outl('    Node node;')
#cog.outl('    switch(cfg.type){');
#for device in device_data['devices']:
#  camel = snake2camel(device['name'])
#  cog.outl('    ')
#            
#  cog.outl('    case ::fastcat::%s_DEVICE:' % device['name'].upper())
#  cog.outl('      node = std::get<::fastcat::%sConfig>(cfg.config_variant);' % camel)
#  cog.outl('      node["device_class"] = "%s";' % camel)
#  cog.outl('    break;')
#cog.outl('    };')
#cog.outl('    node["name"] = cfg.name;')
cog.outl('    return node;')
cog.outl('  }')
cog.outl('')
cog.outl('  static bool decode(const Node& node, ::fastcat::DeviceConfig& cfg) {')

cog.outl('    cfg.name = node["name"].as<std::string>();')
cog.outl('    std::string class_str = node["device_class"].as<std::string>();');
first_time = True
for device in device_data['devices']:
  camel = snake2camel(device['name'])
  if first_time:
    first_time = False
    cog.outl('  if (class_str.compare("%s") == 0) {' % camel)
  else:
    cog.outl('  } else if (class_str.compare("%s") == 0) {' % camel )
    
  cog.outl('      cfg.type = ::fastcat::%s_DEVICE;' % (device['name'].upper()))
  cog.outl('      cfg.config_variant = node.as<::fastcat::%sConfig>();' % camel)
cog.outl('    }')
  

cog.outl('    return true;')
cog.outl('  }')
cog.outl('};')
]]]
[[[end]]]


} // YAML namespace

#endif
