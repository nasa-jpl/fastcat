[[[cog
import yaml
import re

def snake2camel(str):
  return ''.join(x.capitalize() or '_' for x in str.split('_'))

cmd_data     = yaml.load(open(command_yaml, 'r'), Loader=yaml.Loader)
device_data  = yaml.load(open(device_yaml, 'r'), Loader=yaml.Loader)
enum_data    = yaml.load(open(enum_yaml, 'r'), Loader=yaml.Loader)
manager_data = yaml.load(open(manager_yaml, 'r'), Loader=yaml.Loader)

cog.outl('// This file is autogenerated from: %s' % cog_yaml_file)
cog.outl('// using the python cog tool.  Do not modify this file manually.')

]]]
[[[end]]]

#ifndef FASTCAT_TYPES_H_
#define FASTCAT_TYPES_H_


#include <string>
#include <variant>

#include "jsd/jsd_types.h"

namespace fastcat {

//////////////////////////////////
// Manager Configuration Struct
//////////////////////////////////
typedef struct {
[[[cog
for field in manager_data['manager_config']:
  cog.outl('%s %s;' % (field['type'], field['name']))
]]]
[[[end]]]
} MangerConfig;


//////////////////////////////////
// Device Types
//////////////////////////////////
enum DeviceType {
[[[cog
for device in device_data['devices']:
  cog.outl('%s_DEVICE,' % device['name'].upper())
]]]
[[[end]]]
  BAD_DEVICE_TYPE
};


//////////////////////////////////
// Command Types
//////////////////////////////////
enum DeviceCmdType {
[[[cog
for cmd in cmd_data['commands']:
  cog.outl('%s_CMD,' %cmd['name'].upper())
]]]
[[[end]]]
  BAD_DEVICE_CMD_TYPE
};



//////////////////////////////////
// Device Configuration Types
//////////////////////////////////
[[[cog
for this_enum in enum_data['enumerations']:
  is_jsd_enum_alias = False
  if 'jsd_enum_alias' in this_enum:
    is_jsd_enum_alias = bool(this_enum['jsd_enum_alias'])

  cog.outl('enum %s {' % (snake2camel(this_enum['name'])))
  for entry in this_enum['entries']:
    if is_jsd_enum_alias:
      cog.outl('%s = JSD_%s,' % (entry['value'].upper(), entry['value'].upper()))
    else:
      cog.outl('%s,' % entry['value'].upper())
  cog.outl('BAD_%s' % this_enum['name'].upper())
  cog.outl('};')
]]]
[[[end]]]


//////////////////////////////////
// Device States
//////////////////////////////////
[[[cog
for device in device_data['devices']:
  cog.outl('typedef struct {')
  for field in device['state']:
    cog.outl('%s %s;' % (field['type'], field['name']))
  camel = snake2camel(device['name'])
  cog.outl('} %sState;' % camel)
  cog.outl('')

]]]
[[[end]]]

typedef struct {
  std::string name;
  DeviceType type;
  union {
[[[cog
for device in device_data['devices']:
  camel = snake2camel(device['name'])
  cog.outl('%sState %s_state;' % (camel, device['name']) )
]]]
[[[end]]]

  };
  double time;
} DeviceState;

//////////////////////////////////
// Device Config
//////////////////////////////////
[[[cog
for device in device_data['devices']:
  cog.outl('typedef struct {')
  if not 'config' in device:
    cog.outl('bool dummy; // device does not have any config')
  else:
    for field in device['config']:
        cog.outl('%s %s;' % (field['type'], field['name']))
  camel = snake2camel(device['name'])
  cog.outl('} %sConfig;' % camel)
  cog.outl('')

]]]
[[[end]]]


typedef std::variant<
[[[cog
for device in device_data['devices']:
  if device in device_data['devices'][:-1]:
    cog.out('%sConfig,' % (snake2camel(device['name'])) )
  else:
    cog.out('%sConfig' % (snake2camel(device['name'])) )
  cog.out('\n')
]]]
[[[end]]]
> DeviceConfigVariant;

typedef struct{
  std::string name;
  DeviceType type;
  DeviceConfigVariant config_variant;
} DeviceConfig;


//////////////////////////////////
// Device Commands
//////////////////////////////////
[[[cog
for cmd in cmd_data['commands']:
  cog.outl('typedef struct {')
  for field in cmd['fields']:
    cog.outl('%s %s;' % (field['type'], field['name']))
  camel = snake2camel(cmd['name'])
  cog.outl('} %sCmd;' % camel)
  cog.outl('')

]]]
[[[end]]]


typedef struct {
  std::string name;
  DeviceCmdType type;
  union {
[[[cog
for cmd in cmd_data['commands']:
  camel = snake2camel(cmd['name'])
  cog.outl('%sCmd %s_cmd;' % (camel, cmd['name']) )
]]]
[[[end]]]

  };
} DeviceCmd;


//////////////////////////////////
// Signal
//////////////////////////////////

typedef enum {
  DATA_TYPE_UNINITIALIZED,
  DATA_TYPE_BOOL,
  DATA_TYPE_INT8,
  DATA_TYPE_UINT8,
  DATA_TYPE_INT16,
  DATA_TYPE_UINT16,
  DATA_TYPE_INT32,
  DATA_TYPE_UINT32,
  DATA_TYPE_DOUBLE,
} data_type_t;

typedef struct {
  // Yaml input fields
  std::string observed_device_name;
  std::string request_signal_name;
  std::string cmd_field_name;

  // for data fetching and casting
  data_type_t data_type;
  void *data_loc;
  double value;

} Signal;

//////////////////////////////////
// Fault
//////////////////////////////////

enum FaultType {
  NO_FAULT,
  WARNING,
  ALL_DEVICE_FAULT
};

//////////////////////////////////
// Actuator Position Data
//////////////////////////////////

typedef struct{
  double position;
} ActuatorPosData;


typedef struct{
  jsd_sdo_req_t response;
  std::string   device_name;
} SdoResponse;

} // fastcat namespace

#endif
