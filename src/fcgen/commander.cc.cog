[[[cog
import yaml
import re

def snake2camel(str):
  return ''.join(x.capitalize() or '_' for x in str.split('_'))

data = yaml.load(open(cog_yaml_file, 'r'), Loader=yaml.Loader)

cog.outl('// This file is autogenerated from: %s' % cog_yaml_file)
cog.outl('// using the python cog tool.')
cog.outl('// Please make modifications to fcgen/commander.cc.cog')

]]]
[[[end]]]

// Include related header (for cc files)
#include "fastcat/fastcat_devices/commander.h"

// Include c then c++ libraries
#include <cmath>
#include <iostream>
#include <unordered_map>

// Include external then project includes
#include "jsd/jsd_types.h"

#include "fastcat/signal_handling.h"
#include "fastcat/yaml_parser.h"
#include "jsd/jsd_print.h"

fastcat::Commander::Commander()
{
  MSG_DEBUG("Constructed Commander");
  state_       = std::make_shared<DeviceState>();
  state_->type = COMMANDER_STATE;
  
}

bool fastcat::Commander::ConfigFromYaml(YAML::Node node, double external_time)
{
  if (!ParseVal(node, "name", name_)) {
    return false;
  }
  state_->name = name_;

  if (!ParseVal(node, "device_cmd_type", device_cmd_type_string_)) {
    return false;
  }
  device_cmd_.type = DeviceCmdTypeFromString(device_cmd_type_string_);

  if (!ParseVal(node, "device_cmd_name", device_cmd_.name)) {
    return false;
  }

  if (!ParseVal(node, "start_enabled", start_enabled_)) {
    return false;
  }
  state_->commander_state.enable = start_enabled_;
  if(start_enabled_){
    enable_duration_ = 0; // indefinite duration
  }

  if (!ParseVal(node, "skip_n_loops", skip_n_loops_)) {
    return false;
  }


  if (!ConfigSignalsFromYaml(node, signals_, true)) {
    return false;
  }

  int ii;
  std::unordered_map<std::string, int> cmd_fields;
  switch (device_cmd_.type) {

    [[[cog
    for cmd in data['commands']:
      if cmd['name'] == "async_sdo_write" or cmd['name'] == "async_sdo_read":
        continue
      cog.outl('case %s_CMD:' % cmd['name'].upper())
      cog.outl('  if (signals_.size() != %d) {' % len(cmd['fields']))
      cog.outl('    ERROR("Received %s signals when expecting %d for command type %sCmd", signals_.size());' % ('%lu', len(cmd['fields']), snake2camel(cmd['name'])))
      cog.outl('    return false;')
      cog.outl('  }')

      for field in cmd['fields']:
        cog.outl('  cmd_fields.insert({{"%s", 0}});' % field['name'])

      cog.outl('  for (ii = 0; ii < %d; ii++) {' % len(cmd['fields']))
      cog.outl('    if (cmd_fields.find(signals_[ii].cmd_field_name) != cmd_fields.end()) {')
      cog.outl('      cmd_fields[signals_[ii].cmd_field_name]++;')
      cog.outl('    }')
      cog.outl('  }')
      cog.outl('  for (auto it = cmd_fields.begin(); it != cmd_fields.end(); it++) {')
      cog.outl('    if (it->second != 1) {')
      cog.outl('      ERROR("Command field name %s appears %s times in YAML node %s.", it->first.c_str(), it->second);' % ('%s', '%d', cmd['name']))
      cog.outl('      return false;')
      cog.outl('    }')
      cog.outl('  }')
      cog.outl('  break;')
    ]]]
    [[[end]]]
    default:
      ERROR("Unhandled commander type");
      return false;
  }

  if (signals_.size() < 1) {
    ERROR("Expecting at least one signal for Commander");
    return false;
  }

  return true;
}

bool fastcat::Commander::Read()
{

  if(state_->commander_state.enable && enable_duration_ > 0){
    double on_time = state_->time - enable_time_;
    if(on_time > enable_duration_){
      MSG("Commander %s reached enable duration of %lf sec, disabling", 
        name_.c_str(), enable_duration_);
      state_->commander_state.enable = false;
    }
  }
   
  if(skip_counter_++ > skip_n_loops_){
    skip_counter_ = 0;
    return true;
  }

  // update input signal
  for(auto sig = signals_.begin(); sig != signals_.end(); ++sig){
    if (!UpdateSignal(*sig)) {
      ERROR("Could not update signal %s from device %s", 
             sig->cmd_field_name.c_str(), 
             sig->observed_device_name.c_str());
      return false;
    }

    // handle it appropriately in the DeviceCmd message
    switch (device_cmd_.type) {

      [[[cog
      for cmd in data['commands']:
        if cmd['name'] == "async_sdo_write" or cmd['name'] == "async_sdo_read":
          continue
        cog.outl("case %s_CMD:" % cmd['name'].upper())
        cog.out("  ");
        for field in cmd['fields']:
          cog.outl('if(sig->cmd_field_name.compare("%s") == 0){' % field['name'])
          cog.outl('    device_cmd_.%s_cmd.%s = static_cast<%s>(sig->value);' % (
                        cmd['name'], field['name'], field['type'] ))
          cog.out('  } else ')
        cog.outl('{')
        cog.outl('    WARNING("Commander %s has bad cmd_field_name entry: %s",')
        cog.outl('             state_->name.c_str(), sig->cmd_field_name.c_str());')
        cog.outl('  }')
        cog.outl('  break;')

      ]]]
      [[[end]]]

      default:
        ERROR("Unhandled commander type");
        return false;
    }
  }

  // add command message to the command queue, if enabled
  if (state_->commander_state.enable) {
    cmd_queue_->push(device_cmd_);
  }

  return true;
}

bool fastcat::Commander::Write(DeviceCmd& cmd)
{

  if(device_fault_active_){
    ERROR("Commander (%s) cannot be commanded with an active fault, reset first", name_.c_str());
    return false;
  }

  if (cmd.type == COMMANDER_ENABLE_CMD) {
    state_->commander_state.enable = true;
    enable_duration_ = cmd.commander_enable_cmd.duration;
    enable_time_ = state_->time;
  }else if (cmd.type == COMMANDER_DISABLE_CMD) {
    state_->commander_state.enable = false;
  }else{
    WARNING("Bad command to Commander: %s device", 
      name_.c_str());
    return false;
  }

  return true;
}

void fastcat::Commander::Fault()
{
  DeviceBase::Fault();
  state_->commander_state.enable = false;
}

void fastcat::Commander::Reset()
{
  DeviceBase::Reset();
  if (start_enabled_) {
    state_->commander_state.enable = true;
  }
}
