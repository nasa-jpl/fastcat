[[[cog
import yaml
import re

def snake2camel(str):
  return ''.join(x.capitalize() or '_' for x in str.split('_'))

data = yaml.load(open(cog_yaml_file, 'r'), Loader=yaml.Loader)

cog.outl('// This file is autogenerated from: %s' % cog_yaml_file)
cog.outl('// using the python cog tool.')
cog.outl('// Please make modifications to fcgen/signal_handling.cc.cog')

dtype_native_enum = [
  ('bool'    , 'DATA_TYPE_BOOL'),
  ('int8_t'  , 'DATA_TYPE_INT8'),
  ('uint8_t' , 'DATA_TYPE_UINT8'),
  ('int16_t' , 'DATA_TYPE_INT16'),
  ('uint16_t', 'DATA_TYPE_UINT16'),
  ('int32_t' , 'DATA_TYPE_INT32'),
  ('uint32_t', 'DATA_TYPE_UINT32'), 
  ('double'  , 'DATA_TYPE_DOUBLE'),
]

]]]
[[[end]]]

// Include related header (for cc files)
#include "fastcat/signal_handling.h"

// Include c then c++ libraries
#include <string.h>
#include <typeindex>
#include <typeinfo>

// Include external then project includes
#include "fastcat/yaml_parser.h"
#include "jsd/jsd_print.h"


bool fastcat::UpdateSignal(fastcat::Signal &signal) {

  if(signal.observed_device_name.compare("FIXED_VALUE") == 0){
    return true;
  }

  char buffer[sizeof(double)] = {0};

  switch(signal.data_type){
[[[cog

for (native, enum) in dtype_native_enum:
  cog.outl('case %s:' % enum)
  cog.outl('memcpy(buffer, (void *)signal.data_loc, sizeof(%s));' % native)
  cog.outl('signal.value = static_cast<%s>(*(%s*)buffer);' % (native, native));
  cog.outl('break;')

]]]
[[[end]]]

    default:
      ERROR("Signal Extraction is not defined for %s", signal.request_signal_name.c_str());
      return false;
  }
  return true;
}

bool fastcat::ConfigSignalsFromYaml(YAML::Node node,
                                    std::vector<fastcat::Signal> &signals, 
                                    bool is_commander) {
  YAML::Node signals_node;
  if (!ParseList(node, "signals", signals_node)) {
    return false;
  }
  for (auto signal_node = signals_node.begin();
       signal_node != signals_node.end(); ++signal_node) {

    Signal signal;
    signal.data_type = DATA_TYPE_UNINITIALIZED;
    signal.value = 0;

    if (!ParseVal(*signal_node, "observed_device_name",
                  signal.observed_device_name)) {
      return false;
    }

    if(signal.observed_device_name.compare("FIXED_VALUE") == 0){

      if (!ParseVal(*signal_node, "fixed_value",
                    signal.value)) {
        return false;
      }
      
    } else { // device state signal
      if (!ParseVal(*signal_node, "request_signal_name",
                    signal.request_signal_name)) {
        return false;
      }
    }

    if(is_commander){
      if (!ParseVal(*signal_node, "cmd_field_name",
                    signal.cmd_field_name)) {
        return false;
      }
    }

    signals.push_back(signal);
  }
  return true;
}


bool fastcat::ConfigSignalByteIndexing(fastcat::DeviceState *state,
                                       fastcat::Signal &signal) {

  if(signal.observed_device_name.compare("FIXED_VALUE") == 0){
    return true;
  }

  switch (state->type) {

[[[cog
for state in data['states']:
  cog.outl('case %s_STATE:' % state['name'].upper())

  if(len(state['fields']) == 0):
    cog.outl('ERROR("%s has no valid signals);' % state['name'].upper());
    cog.outl('return false;');
  else:
    for field in state['fields']:

      cog.outl('if (signal.request_signal_name.compare("%s") == 0) {' % field['name']);

      dtype_tuple = [(native, enum) for native, enum in dtype_native_enum if native == field['type']] 
      if len(dtype_tuple) > 0:
        cog.outl('  signal.data_loc = (void *)&state->%s_state.%s;' % (state['name'], field['name']))
        cog.outl('  signal.data_type = %s;' % (dtype_tuple[0][1]))
        cog.outl('  return true;')
        cog.out('}')
      else:
        cog.outl(' ERROR("%s cannot be used as signal, wrong type: %s");' % (field['name'], field['type']))
        cog.outl('  return false;')
        cog.out('}')
   
    cog.outl('else {')
    cog.outl('  ERROR("%s invalid signal: %s", signal.request_signal_name.c_str());' % (state['name'].upper(), "%s"))
    cog.outl('  return false;')
    cog.outl('}')
  cog.outl('break;')
  cog.outl('')
  

]]]
[[[end]]]


  default:
    ERROR("Signal Extraction not defined for DeviceStateType %d", state->type);
    return false;
  }
  return true;
}

enum fastcat::DeviceCmdType fastcat::DeviceCmdTypeFromString(std::string str) {

[[[cog

for cmd in data['commands']:
  cog.outl('if (std::string("%s_CMD").compare(str) == 0) {' % cmd['name'].upper())
  cog.outl('  return fastcat::%s_CMD;' % cmd['name'].upper())
  cog.outl('}');
  cog.outl('');

]]]
[[[end]]]

  return fastcat::BAD_DEVICE_CMD;
}
